# 家族ひもづけ機能 仕様検討

## 📋 概要

現在の「1つのLINEアカウント = 1枚の診察券（1つのスタンプ数）」という1:1構造を、**家族単位でスタンプを共有できる仕組み**に拡張します。

**作成日:** 2026-02-16
**ステータス:** 🚧 検討中（未実装）

---

## 🎯 実現したいこと

### ユースケース

| ケース | 現状 | 理想 |
|-------|------|------|
| **母親が子供を連れて来院** | 母親のスタンプ+1、子供のスタンプ+1（別々） | 家族のスタンプ+2（共有財布） |
| **父親が定期検診** | 父親のスタンプ+1 | 家族のスタンプ+1（同じ財布に貯まる） |
| **特典交換** | 母親が10個貯めて交換 | 家族で10個貯めたら誰でも交換可能 |
| **独立・離婚** | - | スタンプを分配して家族解除 |

### 目的

- 👨‍👩‍👧‍👦 家族全員の来院をモチベーション向上
- 💰 家族単位の「共通財布」でスタンプ管理
- 🔧 管理ダッシュボードで柔軟に紐付け・解除

---

## 📐 提案されたスキーマ構成（原案）

### 1. 新設: `families` テーブル

世帯（お財布）の実体。

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 家族ID（主キー） |
| family_name | TEXT | 「○○家」などの表示用名称 |
| total_stamp_count | **NUMERIC** | 世帯の合計スタンプ数（**0.1単位対応**） |
| created_at | TIMESTAMPTZ | 作成日時 |
| updated_at | TIMESTAMPTZ | 更新日時 |

### 2. 修正: `profiles` テーブル

個人（LINEユーザー兼、患者個人）のデータ。

| カラム名（追加） | 型 | 説明 |
|---------------|---|------|
| family_id | UUID (FK) | 所属する families.id への参照 |
| family_role | TEXT | 'parent' (親/代表) / 'child' (子/一般) |
| stamp_count | NUMERIC | **参照用キャッシュ**（families.total_stamp_count と同期） |

### 3. 修正: `stamp_history` テーブル

「誰が」獲得して「どの家族」に貯まったかを記録。

| カラム名（変更） | 型 | 説明 |
|---------------|---|------|
| family_id | UUID (FK) | 加算先の families.id（**新規追加**） |
| amount | **NUMERIC** | 付与量（1.0 または スロットの結果 0.3〜0.8）【stamp_number から変更】 |

---

## ⚠️ 原案の懸念点・矛盾・検討事項

### 🔴 重大な懸念

#### 1. **既存設計との矛盾: stamp_number の役割変更**

**現在の設計:**
- `stamp_history.stamp_number` = **その時点でのスタンプ数（累積）**
- `profiles.stamp_count = MAX(stamp_number)` で計算（トリガー）
- 訪問回数 = `COUNT(*)`, スタンプ数 = `MAX(stamp_number)`

**原案の変更:**
- `stamp_history.amount` = **1回の付与量**（差分）
- `families.total_stamp_count = SUM(amount)` で計算

**問題点:**
- 既存の `update_profile_stamp_count()` トリガー関数が動作しなくなる
- 既存データの移行が複雑（累積値 → 差分値への変換）
- スタッフ手動編集の履歴（`stamp_number` で管理）が壊れる

**影響度:** 🔥🔥🔥 **非常に大きい** - 根本的な設計変更

---

#### 2. **0.1単位のスタンプ管理の必要性**

**原案の理由:**
- スロットゲームで 0.3〜0.8 スタンプを付与したい

**懸念点:**
- 0.1単位の管理は複雑化を招く
  - UI表示: 「12.7個」「14.3個」→ ユーザーが混乱
  - 特典交換: 「10.0個必要」→ 9.9個では交換できない？ 10.1個なら？
  - データベース: NUMERIC 型の精度管理が必要
- **「1回来院 = 1スタンプ」のシンプルさが失われる**

**代替案:**
- スロットゲームは独立したポイント制にする
- 来院スタンプは整数のまま維持
- 小数スタンプは Phase 後回し

**影響度:** 🟡🟡 **中程度** - 仕様の複雑化

---

#### 3. **データ整合性の複雑化**

**同期が必要な箇所:**
1. `families.total_stamp_count` ↔ `SUM(stamp_history.amount WHERE family_id = ...)`
2. `profiles.stamp_count` ↔ `families.total_stamp_count`（キャッシュ）

**問題点:**
- トリガーが複雑化（INSERT, UPDATE, DELETE の全てに対応）
- 同期ミスが発生した場合の修正が困難
- 家族の紐付け変更時に履歴の family_id を書き換える？（履歴改竄になる）

**例: Aさん（単身）が Bさん家族に参加した場合**
```
Aさんの過去の stamp_history の family_id を B家族に変更？
→ 履歴が「元々B家族だった」ように見えてしまう
→ 監査証跡として不適切
```

**影響度:** 🟡🟡 **中程度** - 運用の複雑化

---

### 🟡 運用上の懸念

#### 4. **特典交換時の権限・ルール**

**未定義の仕様:**
- 家族の誰が交換できる？
  - 親（parent）のみ？
  - 子供（child）も交換可能？
- 交換履歴（reward_exchanges）の記録は？
  - 「誰が」交換したか？
  - 「どの家族のスタンプを使ったか？」

**検討が必要:**
- 子供が勝手に交換できると親が困る
- でも、子供本人の来院ポイントも含まれている

**影響度:** 🟡 **中程度** - 仕様の曖昧さ

---

#### 5. **プライバシー・権限管理**

**未定義の仕様:**
- 子供が親のスタンプ数を見られる？
- 親が子供の来院履歴を見られる？
- family_role の 'parent' と 'child' の権限差は？

**例:**
- 高校生の子供が「親に内緒で歯科に通っている」場合
- 親のLINEアプリで子供の来院履歴が見えてしまう？

**影響度:** 🟢 **小さい** - 運用ルールで解決可能

---

#### 6. **家族解除（分家）時のスタンプ分配ルール**

**原案:**
> 「家族の共通スタンプから、何ポイント持って独立するか」をスタッフが入力

**懸念点:**
- 誰がどれだけ貯めたかの公平性
  - 母親が10回来院、子供が2回来院 → 合計12個
  - 子供が独立する時、何個持っていく？
- 離婚などのデリケートなケース
  - 「半分ずつ」が公平？
  - 「来院回数に応じて」が公平？

**stamp_history に user_id と family_id の両方を記録する理由:**
- 「誰が貯めたか」の履歴を残す
- 分家時の参考データにする

**影響度:** 🟡 **中程度** - 運用ルールの策定が必要

---

#### 7. **既存ユーザーのマイグレーション**

**原案:**
> 新規登録時に必ず families レコードを1つ作成

**懸念点:**
- 既存の全ユーザーに families を作成する必要がある
- `stamp_history` の既存データに family_id を付与する必要がある
- `stamp_number`（累積値） → `amount`（差分値）への変換

**マイグレーション手順（例）:**
```sql
-- 1. 全ユーザーに families を作成
INSERT INTO families (id, family_name, total_stamp_count)
SELECT gen_random_uuid(), display_name || '家', stamp_count
FROM profiles;

-- 2. profiles に family_id を設定
UPDATE profiles SET family_id = (SELECT id FROM families WHERE ...);

-- 3. stamp_history に family_id を設定
UPDATE stamp_history SET family_id = (
  SELECT family_id FROM profiles WHERE id = stamp_history.user_id
);

-- 4. stamp_number → amount への変換（差分計算が複雑）
-- 例: stamp_number が 1, 2, 5, 6 の場合 → amount は 1, 1, 3, 1
```

**影響度:** 🔥🔥 **大きい** - データ移行の複雑さ

---

## 💡 改善案・代替案

### 案1: シンプルな家族グループ（整数のみ、推奨）

**変更点:**
- ✅ 0.1単位は廃止 → **INTEGER のまま**
- ✅ `stamp_history` は既存設計のまま（`stamp_number` 累積値）
- ✅ `families.total_stamp_count` は **家族全員の stamp_count の合計**（計算値）

**スキーマ:**

```sql
-- 新設: families テーブル
CREATE TABLE families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_name TEXT NOT NULL,
  representative_user_id TEXT REFERENCES profiles(id), -- 代表者
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- profiles テーブルに追加
ALTER TABLE profiles
  ADD COLUMN family_id UUID REFERENCES families(id),
  ADD COLUMN family_role TEXT DEFAULT 'member' CHECK (family_role IN ('representative', 'member'));

-- ビュー: 家族の合計スタンプ数
CREATE VIEW family_stamp_totals AS
SELECT
  family_id,
  SUM(stamp_count) AS total_stamp_count,
  COUNT(*) AS member_count
FROM profiles
WHERE family_id IS NOT NULL
GROUP BY family_id;
```

**メリット:**
- ✅ 既存の `stamp_history` 設計を維持
- ✅ トリガー関数の変更不要
- ✅ 整数のみでシンプル
- ✅ `total_stamp_count` は VIEW で計算（同期不要）

**デメリット:**
- ❌ スロットゲームの小数スタンプは未対応（別システムで管理）

---

### 案2: 最小限拡張（家族紐付けのみ）

**変更点:**
- ✅ `profiles` に `family_id` を追加するだけ
- ✅ `families` テーブルは作らない
- ✅ 表示時に「家族の合計」を計算（`SUM(stamp_count) WHERE family_id = ...`）

**メリット:**
- ✅ 最もシンプル
- ✅ データベース変更が最小限

**デメリット:**
- ❌ 家族名が保存できない
- ❌ 家族の代表者が不明

---

### 案3: 段階的導入

**Phase 1: 紐付けのみ**
- `profiles.family_id` を追加
- 管理ダッシュボードで家族紐付け機能実装
- 表示は個人のスタンプ数のまま

**Phase 2: 家族合計の表示**
- 家族合計スタンプ数を画面に表示
- 「あなた: 5個、家族全体: 12個」

**Phase 3: 特典交換時に家族スタンプ使用可能**
- 交換時に「個人スタンプ」or「家族スタンプ」を選択
- 権限管理の実装

**Phase 4: 小数スタンプ対応（オプション）**
- スロットゲームなどの特殊ケース

**メリット:**
- ✅ リスク分散
- ✅ ユーザーフィードバックを得ながら改善

---

### 案4: 10倍整数管理案（★最推奨★）

**コンセプト:**
- **内部数値を10倍して整数で管理**
- **「10点 = スタンプ1個」と定義**
- ユーザーには「スタンプ個数 + 進捗ゲージ」で表示

**スキーマ（確定版）:**

```sql
-- ① profiles テーブル（拡張）
ALTER TABLE profiles
  ADD COLUMN visit_count INTEGER DEFAULT 0,    -- 【新設】純粋な来院回数
  ADD COLUMN family_id UUID REFERENCES families(id);

-- stamp_count は既存のまま（累積ポイント、整数）
COMMENT ON COLUMN profiles.stamp_count IS '累積ポイント（内部単位: 10点 = スタンプ1個）';
COMMENT ON COLUMN profiles.visit_count IS '純粋な来院回数（スロット除く通院のみカウント）';

-- ② stamp_history テーブル（拡張）
ALTER TABLE stamp_history
  ADD COLUMN amount INTEGER NOT NULL DEFAULT 10,  -- 【新設】今回付与したポイント
  ADD COLUMN family_id UUID REFERENCES families(id);

-- stamp_number は既存のまま（累積ポイント、整数）
COMMENT ON COLUMN stamp_history.stamp_number IS '付与後の累積ポイント';
COMMENT ON COLUMN stamp_history.amount IS '今回付与したポイント（通院=10、スロット=3〜8）';

-- 例: 合計135点 = スタンプ13.5個
--   → 表示: 「スタンプ13個 + ゲージ50%」
```

**スタンプ付与ルール:**

| アクション | 付与ポイント<br>(amount) | visit_count | stamp_number<br>(累積) | 備考 |
|-----------|----------------------|-------------|---------------------|------|
| 通常の通院 | +10 | +1 | 累積 +10 | 診察券1枚につき付与 |
| スロット当選（最小） | +3 | +0 | 累積 +3 | 通院時のみ発生するボーナス |
| スロット当選（中） | +5 | +0 | 累積 +5 | 〃 |
| スロット当選（最大） | +8 | +0 | 累積 +8 | 〃 |
| スタッフ手動編集 | 任意 | ±任意 | 任意 | 監査証跡に記録 |

**家族合算の計算:**
- **家族の合計ポイント**: `SUM(profiles.stamp_count WHERE family_id = 'xxx')`
- **家族の合計来院回数**: `SUM(profiles.visit_count WHERE family_id = 'xxx')`

**表示計算:**
```typescript
// 内部値: stamp_count = 135点
const fullStamps = Math.floor(stamp_count / 10);  // 13個
const progress = (stamp_count % 10) * 10;         // 50%

// 表示: 「スタンプ13個 🎖 次まであと50%」
```

**UI/UX例:**
```
┌─────────────────────────────────────┐
│ 🏠 横山家                            │
│ スタンプ 23個 🎖                     │
│ [■■■■■■■□□□] 次まであと30%       │
│                                      │
│ あなた: 12個                         │
│ 花子さん: 8個                        │
│ 一郎くん: 3個                        │
└─────────────────────────────────────┘
```

**メリット:**

✅ **既存設計を完全維持**
- `stamp_history.stamp_number` は整数のまま（10, 20, 30...）
- トリガー関数の変更不要（MAX(stamp_number) がそのまま動く）
- 既存データのマイグレーション不要（×10するだけ）

✅ **小数の精度問題を完全回避**
- 整数計算のみ → 浮動小数点の誤差が絶対に起きない
- DECIMAL型不要、INTEGER のまま

✅ **UI/UXがわかりやすい**
- ユーザーには「スタンプ個数」として表示
- 端数は「ゲージ（経験値バー）」で視覚化
- ゲーム感覚で楽しい

✅ **スロットゲームとの統合が自然**
- 「スタンプ」と「スロットポイント」の2つの単位が不要
- 全て「スタンプ」に統一できる

✅ **家族共有との相性が良い**
- 家族全員の点数を合算するだけ
- 分家時の分配も計算しやすい

**デメリット:**

⚠️ **表示ロジックの追加**
- フロントエンドで「÷10」の計算が必要
- しかし、計算式は単純（`Math.floor(value / 10)`）

⚠️ **既存ユーザーのデータ×10**
- マイグレーション時に `stamp_count * 10` が必要
- ただし、単純な乗算なので移行は容易

**実装例:**

```typescript
// lib/stamps.ts
export const STAMP_UNIT = 10; // 1スタンプ = 10点

export function calculateStampDisplay(points: number) {
  return {
    fullStamps: Math.floor(points / STAMP_UNIT),
    progress: (points % STAMP_UNIT) * 10, // 0〜90%
    totalPoints: points
  };
}

// 使用例
const { fullStamps, progress } = calculateStampDisplay(135);
// → fullStamps: 13, progress: 50
```

**トリガー関数の更新:**

```sql
-- トリガー関数: profiles の stamp_count と visit_count を自動更新
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE profiles
  SET
    -- 累積ポイント = MAX(stamp_number)
    stamp_count = (
      SELECT COALESCE(MAX(stamp_number), 0)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    -- 来院回数 = amount = 10 のレコード数（通常来院のみ）
    visit_count = (
      SELECT COUNT(*)
      FROM stamp_history
      WHERE user_id = NEW.user_id AND amount = 10
    ),
    last_visit_date = (
      SELECT MAX(visit_date)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    updated_at = NOW()
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- トリガーは既存のまま（AFTER INSERT on stamp_history）
```

**マイグレーション:**

```sql
-- 008_convert_to_10x_system.sql

-- ① 既存データを10倍に変換
UPDATE profiles SET stamp_count = stamp_count * 10;
UPDATE stamp_history SET stamp_number = stamp_number * 10;

-- ② 新しいカラムを追加
ALTER TABLE profiles ADD COLUMN visit_count INTEGER DEFAULT 0;
ALTER TABLE stamp_history ADD COLUMN amount INTEGER DEFAULT 10;

-- ③ amount の値を逆算して埋める（既存データ）
WITH ordered_history AS (
  SELECT
    id,
    stamp_number,
    LAG(stamp_number, 1, 0) OVER (PARTITION BY user_id ORDER BY visit_date) AS prev_stamp_number
  FROM stamp_history
)
UPDATE stamp_history sh
SET amount = oh.stamp_number - oh.prev_stamp_number
FROM ordered_history oh
WHERE sh.id = oh.id;

-- ④ visit_count の値を計算して埋める（既存データ）
UPDATE profiles p
SET visit_count = (
  SELECT COUNT(*)
  FROM stamp_history
  WHERE user_id = p.id AND amount = 10
);

-- ⑤ コメント更新
COMMENT ON COLUMN profiles.stamp_count IS '累積ポイント（内部単位: 10点 = スタンプ1個）';
COMMENT ON COLUMN profiles.visit_count IS '純粋な来院回数（スロット除く通院のみカウント）';
COMMENT ON COLUMN stamp_history.stamp_number IS '付与後の累積ポイント';
COMMENT ON COLUMN stamp_history.amount IS '今回付与したポイント（通院=10、スロット=3〜8）';
```

**訪問回数とスタンプ数の分離（確定版）:**

10倍整数管理でも、**「来院回数」「累積ポイント」「今回の付与量」の3つの概念**が明確に分離されます。

| 概念 | 格納場所 | 説明 |
|-----|---------|------|
| **来院回数** | `profiles.visit_count` | 純粋な通院回数（スロット除く） |
| **累積ポイント（内部）** | `profiles.stamp_count` | 累積スタンプ点数（10倍単位） |
| **今回の付与量** | `stamp_history.amount` | その訪問で付与したポイント |
| **付与後の累積** | `stamp_history.stamp_number` | その時点での累積ポイント |
| **スタンプ数（表示）** | `floor(stamp_count / 10)` | ユーザーに見せるスタンプ個数 |

**例: 横山太郎さんの履歴**

```
訪問履歴（stamp_history）:
┌────────┬───────────┬────────┬──────────┬─────────────┐
│ 訪問   │ 日時      │ amount │ stamp_   │ visit_count │
│        │           │ (付与) │ number   │ (累積)      │
│        │           │        │ (累積)   │             │
├────────┼───────────┼────────┼──────────┼─────────────┤
│ 1回目  │ 2/1 09:00 │ 10     │ 10       │ 1           │ 通常来院
│ 2回目  │ 2/8 10:00 │ 10     │ 20       │ 2           │ 通常来院
│ -      │ 2/8 10:05 │ 3      │ 23       │ 2           │ スロット当選
│ 3回目  │ 2/15 14:00│ 10     │ 33       │ 3           │ 通常来院
└────────┴───────────┴────────┴──────────┴─────────────┘

profiles テーブル:
- visit_count: 3回（通院のみカウント、スロットは除く）
- stamp_count: 33点（累積ポイント）

ユーザーへの表示:
- 来院回数: 3回
- スタンプ: 3個 + ゲージ30%（33点 ÷ 10 = 3 あまり 3）
```

**この設計のメリット:**
- ✅ **来院回数の正確性**: `visit_count` で明示的に管理（スロットは含まない）
- ✅ **付与履歴の可読性**: `amount` で「今回何点もらったか」が一目瞭然
- ✅ **スタッフ手動編集が可能**: `stamp_number` を直接変更できる
- ✅ **監査証跡の完璧性**: 全ての変更が履歴に残る
- ✅ **トリガー関数の変更不要**: `MAX(stamp_number)` がそのまま動く

---

## 📊 比較表

| 項目 | 原案 | 案1（整数） | 案2（最小限） | 案3（段階的） | 案4（10倍★） |
|-----|------|-----------|-------------|-------------|-------------|
| 0.1単位対応 | ✅ DECIMAL | ❌ | ❌ | △（Phase 4） | ✅ 整数×10 |
| 既存設計維持 | ❌ | ✅ | ✅ | ✅ | ✅✅ |
| 小数精度問題 | 🔴 DECIMAL必須 | - | - | - | 🟢 完全回避 |
| データ整合性 | 🔴 複雑 | 🟢 VIEW計算 | 🟢 シンプル | 🟢 段階的 | 🟢 シンプル |
| トリガー変更 | 🔴 必要 | 🟢 不要 | 🟢 不要 | 🟢 不要 | 🟢 不要 |
| マイグレーション | 🔴 困難 | 🟡 中程度 | 🟢 容易 | 🟢 段階的 | 🟢 容易（×10） |
| UI/UX | 🟡 小数表示 | 🟢 整数のみ | 🟢 整数のみ | 🟢 段階的 | 🟢🟢 ゲージ |
| スロット統合 | ✅ | ❌ 別管理 | ❌ 別管理 | △ | ✅✅ 自然 |
| 実装コスト | 🔴 大 | 🟡 中 | 🟢 小 | 🟡 中（分割） | 🟡 中 |
| リスク | 🔴 高 | 🟡 中 | 🟢 低 | 🟢 低 | 🟢 低 |

---

## 🎯 推奨案: 案4（10倍整数管理） + 案3（段階的導入）

### 理由

1. **原案の良い点を全て実現**
   - ✅ 0.1単位のスタンプ管理（スロットゲーム対応）
   - ✅ 既存設計との整合性維持
   - ✅ 小数の精度問題を完全回避

2. **既存設計との整合性**
   - `stamp_history.stamp_number`（累積値）を維持
   - トリガー関数の変更不要
   - INTEGER型のまま（DECIMAL不要）

3. **UI/UXの向上**
   - 「スタンプ個数 + 進捗ゲージ」でゲーム感覚
   - 「1回来院 = 1スタンプ」のわかりやすさは維持
   - 端数はゲージで視覚化（12.7個 → 12個 + 70%）

4. **スロットゲームとの統合**
   - 「スタンプ」と「スロットポイント」の2つの単位不要
   - 全て「スタンプ」に統一

5. **リスク分散**
   - 段階的に導入してフィードバックを得る

6. **実装の容易さ**
   - マイグレーション: 既存データを×10するだけ
   - 表示ロジック: 単純な割り算（÷10）

---

## 📋 実装計画（推奨案ベース）

### Phase 1: データベース拡張（1〜2日）

```sql
-- 008_add_family_support.sql

-- families テーブル作成
CREATE TABLE families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_name TEXT NOT NULL,
  representative_user_id TEXT REFERENCES profiles(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- profiles テーブル拡張
ALTER TABLE profiles
  ADD COLUMN family_id UUID REFERENCES families(id),
  ADD COLUMN family_role TEXT DEFAULT 'member'
    CHECK (family_role IN ('representative', 'member'));

-- インデックス
CREATE INDEX idx_profiles_family_id ON profiles(family_id);

-- 家族合計スタンプ数のビュー
CREATE VIEW family_stamp_totals AS
SELECT
  f.id AS family_id,
  f.family_name,
  f.representative_user_id,
  SUM(p.stamp_count) AS total_stamp_count,
  COUNT(p.id) AS member_count,
  MAX(p.last_visit_date) AS last_family_visit
FROM families f
LEFT JOIN profiles p ON p.family_id = f.id
GROUP BY f.id, f.family_name, f.representative_user_id;

-- 既存ユーザーに家族を作成（単身者として）
INSERT INTO families (id, family_name, representative_user_id)
SELECT gen_random_uuid(), display_name || 'の家族', id
FROM profiles;

UPDATE profiles p
SET
  family_id = (SELECT id FROM families WHERE representative_user_id = p.id),
  family_role = 'representative';
```

---

### Phase 2: 管理ダッシュボード実装（3〜5日）

**機能:**
- 患者詳細パネルに「家族情報」セクション追加
- 家族の紐付け・解除UI
- 家族メンバー一覧表示

**画面イメージ:**
```
┌─────────────────────────────────────┐
│ 患者詳細: 横山太郎                   │
├─────────────────────────────────────┤
│ 👨‍👩‍👧‍👦 家族情報                        │
│                                      │
│ 家族名: 横山家                        │
│ 代表者: 横山太郎 (本人)                │
│ メンバー:                             │
│   - 横山太郎（代表） 12個              │
│   - 横山花子（配偶者） 8個             │
│   - 横山一郎（子供） 3個               │
│                                      │
│ 家族合計: 23個                        │
│                                      │
│ [メンバー追加] [家族解除]             │
└─────────────────────────────────────┘
```

---

### Phase 3: LIFF側の表示（2〜3日）

**表示内容:**
- 個人のスタンプ数: 12個
- 家族全体のスタンプ数: 23個
- 特典交換時の選択: 「個人のスタンプで交換」「家族のスタンプで交換」

**画面イメージ:**
```
┌─────────────────────────────────────┐
│ 🏠 横山家                            │
│ 家族全体: 23個 🎖                    │
│ あなた: 12個                         │
├─────────────────────────────────────┤
│ 👨 横山太郎（あなた） 12個            │
│ 👩 横山花子 8個                      │
│ 👦 横山一郎 3個                      │
└─────────────────────────────────────┘
```

---

### Phase 4: 特典交換の拡張（2〜3日）

**機能:**
- 家族スタンプを使った特典交換
- 交換時の権限チェック（代表者のみ？全員OK？）
- 交換履歴に「誰が」「どのスタンプで」を記録

---

## ⚠️ 残課題・検討事項

### 1. 特典交換の権限ルール

**選択肢:**
- **A案: 全員が交換可能** → シンプルだが、子供が勝手に交換する問題
- **B案: 代表者のみ** → 安全だが、柔軟性が低い
- **C案: 代表者が許可設定** → 柔軟だが、実装コストが高い

**推奨: A案（全員可能）**
- 理由: 家族は信頼関係があることが前提
- 問題があれば Phase 3 で B案に変更

---

### 2. 家族解除時のスタンプ分配

**選択肢:**
- **A案: 管理画面で手動分配** → 柔軟だが、運用負荷
- **B案: 来院回数に比例** → 公平だが、計算が複雑
- **C案: 半分ずつ** → シンプルだが、不公平感

**推奨: A案（手動分配）**
- 理由: ケースバイケースで対応が必要
- スタッフが履歴を見て判断

---

### 3. 小数スタンプの扱い

**スロットゲームで 0.3〜0.8 を付与したい場合:**

**選択肢:**
- **A案: 別システム** → スロットポイントは独立した仕組み
- **B案: Phase 4 で対応** → 必要性を再評価してから実装

**推奨: A案（別システム）**
- 理由: 来院スタンプの整数性を維持

---

## 📝 まとめ

### ✅ 原案の良い点

- 単身者を「1人家族」として統一的に扱う発想
- 管理ダッシュボードでの手動操作による不正防止
- 履歴に `family_id` を記録する考え方

### ⚠️ 原案の問題点

- **0.1単位のスタンプ管理は過度に複雑**
- **stamp_number から amount への変更は既存設計と矛盾**
- **データ整合性の維持が困難**
- **マイグレーションが複雑**

### 💡 推奨案

**案1（整数ベース） + 案3（段階的導入）**
- 既存設計を維持しつつ、家族紐付け機能を追加
- `families` テーブル + `profiles.family_id` 拡張
- `total_stamp_count` は VIEW で計算（同期不要）
- 段階的に実装してリスク分散

---

## 📚 関連ドキュメント

- [05_Database_Schema.md](05_Database_Schema.md) - 現在のデータベーススキーマ
- [03_管理ダッシュボード仕様書.md](03_管理ダッシュボード仕様書.md) - 既存機能の仕様
- [99_変更履歴.md](99_変更履歴.md) - 実装状況・タスク

---

## 改訂履歴

| 日付 | バージョン | 内容 |
|------|----------|------|
| 2026-02-16 | 0.1 | 初版作成：原案の分析、問題点の洗い出し、代替案の提示 |

---

**作成者:** Claude Code
**最終更新日:** 2026-02-16
**ステータス:** 🚧 検討中
