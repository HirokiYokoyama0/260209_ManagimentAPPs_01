# 008マイグレーション実行前チェックリスト

**作成日:** 2026-02-16
**対象:** `supabase/008_add_10x_system_columns.sql`
**ステータス:** 🔍 実行前確認

---

## 📋 目次

1. [マイグレーション内容の概要](#マイグレーション内容の概要)
2. [影響範囲の分析](#影響範囲の分析)
3. [安全性の確認](#安全性の確認)
4. [実行前チェックリスト](#実行前チェックリスト)
5. [リスクと対策](#リスクと対策)
6. [ロールバック手順](#ロールバック手順)
7. [実行判定](#実行判定)

---

## マイグレーション内容の概要

### 目的

将来のスロットゲーム対応のため、スタンプ管理を10倍単位に変更する準備。

### 変更内容

| # | 操作 | 対象 | 内容 |
|---|------|------|------|
| ① | ADD COLUMN | `profiles` | `visit_count` カラム追加（純粋な来院回数） |
| ② | ADD COLUMN | `stamp_history` | `amount` カラム追加（今回付与したポイント） |
| ③ | UPDATE | `stamp_history` | 既存データの `amount` を 10 に設定 |
| ④ | UPDATE | `profiles` | 既存データの `visit_count` を計算 |
| ⑤ | CREATE OR REPLACE | FUNCTION | トリガー関数を更新（`visit_count` 自動計算追加） |
| ⑥ | COMMENT | - | コメント追加（将来の理解のため） |

---

## 影響範囲の分析

### ✅ 影響するテーブル

#### 1. `profiles` テーブル

**既存カラム（変更なし）:**
- `id`, `line_user_id`, `display_name`, `picture_url`
- `stamp_count`, `ticket_number`, `last_visit_date`
- `created_at`, `updated_at`

**追加カラム:**
```sql
visit_count INTEGER DEFAULT 0
```

**影響度:** 🟢 低リスク
- 新規カラム追加のみ（既存カラムの変更なし）
- `DEFAULT 0` により既存データに NULL が入らない
- `IF NOT EXISTS` により冪等性あり（再実行しても安全）

#### 2. `stamp_history` テーブル

**⚠️ 重要:** このテーブルの詳細定義が不明（007マイグレーションが欠番）

**追加カラム:**
```sql
amount INTEGER NOT NULL DEFAULT 10
```

**既存データへの影響:**
- UPDATE で既存レコードの `amount` を 10 に設定
- `user_id` を使って `profiles` と連携

**影響度:** 🟡 中リスク
- `stamp_history` テーブルの存在が前提
- テーブルが存在しない場合はエラー

#### 3. トリガー関数 `update_profile_stamp_count()`

**変更内容:**
```sql
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
```

**新規計算ロジック:**
- `visit_count` = `amount = 10` のレコード数（通常来院のみカウント）

**影響度:** 🟡 中リスク
- `CREATE OR REPLACE` により既存関数を上書き
- トリガーが既に設定されている場合、動作が変わる可能性

---

## 安全性の確認

### ✅ 安全な点

1. **冪等性**
   - `IF NOT EXISTS` を使用（既にカラムが存在する場合はスキップ）
   - 再実行しても安全

2. **デフォルト値の設定**
   - `visit_count DEFAULT 0` により NULL が入らない
   - `amount NOT NULL DEFAULT 10` により既存データも安全

3. **既存データの保護**
   - `profiles.stamp_count` は変更しない
   - 既存カラムは一切変更しない

4. **コメント追加**
   - 将来の開発者が仕様を理解しやすい

### ⚠️ 注意が必要な点

1. **`stamp_history` テーブルの存在確認が必要**
   - このテーブルが存在しない場合、マイグレーションはエラーになる
   - 007マイグレーションが欠番（`stamp_history` の作成スクリプトが見つからない）

2. **トリガー関数の上書き**
   - `CREATE OR REPLACE` により既存関数を上書き
   - 既存のトリガーが設定されている場合、動作が変わる可能性

3. **既存データへのUPDATE**
   - ③④で既存データを更新
   - データ量が多い場合、時間がかかる可能性

---

## 実行前チェックリスト

### 必須確認事項

- [ ] **1. `stamp_history` テーブルの存在確認**
  ```sql
  SELECT table_name
  FROM information_schema.tables
  WHERE table_schema = 'public'
  AND table_name = 'stamp_history';
  ```

  **確認方法:** Supabase SQL Editor で上記を実行

  **期待結果:** `stamp_history` テーブルが存在すること

- [ ] **2. `stamp_history` テーブルのカラム確認**
  ```sql
  SELECT column_name, data_type, is_nullable
  FROM information_schema.columns
  WHERE table_name = 'stamp_history'
  ORDER BY ordinal_position;
  ```

  **期待結果:**
  - `user_id` カラムが存在すること
  - `stamp_number` カラムが存在すること
  - `visit_date` カラムが存在すること

- [ ] **3. 既存トリガーの確認**
  ```sql
  SELECT trigger_name, event_manipulation, event_object_table, action_statement
  FROM information_schema.triggers
  WHERE trigger_schema = 'public'
  AND event_object_table = 'stamp_history';
  ```

  **期待結果:** `update_profile_stamp_count` トリガーが設定されていること

- [ ] **4. `stamp_history` の既存データ件数確認**
  ```sql
  SELECT COUNT(*) as total_records FROM stamp_history;
  ```

  **期待結果:** 件数を確認（UPDATEの所要時間の目安）

- [ ] **5. バックアップの確認**
  - Supabase の自動バックアップが有効か確認
  - または手動でバックアップを取得

### 推奨確認事項

- [ ] **6. 現在の `profiles.stamp_count` と想定される `visit_count` の整合性確認**
  ```sql
  SELECT
    p.id,
    p.display_name,
    p.stamp_count,
    COUNT(sh.*) as calculated_visit_count
  FROM profiles p
  LEFT JOIN stamp_history sh ON sh.user_id = p.id
  GROUP BY p.id, p.display_name, p.stamp_count
  ORDER BY p.stamp_count DESC
  LIMIT 10;
  ```

  **期待結果:** `stamp_count` と `calculated_visit_count` が一致すること（現在は1:1の想定）

- [ ] **7. 開発環境での事前テスト**
  - 可能であれば、開発環境で先に実行して動作確認

---

## リスクと対策

### リスク1: `stamp_history` テーブルが存在しない

**発生条件:** 007マイグレーションが未実行の場合

**影響:**
- マイグレーション実行時にエラー
- `profiles` テーブルには `visit_count` が追加されるが、`stamp_history` 関連の処理が失敗

**対策:**
1. 事前に `stamp_history` テーブルの存在を確認
2. 存在しない場合は、007マイグレーション（または相当するスクリプト）を先に実行

### リスク2: トリガー関数の上書きによる既存機能への影響

**発生条件:** 既存のトリガー関数が異なるロジックで動作していた場合

**影響:**
- スタンプ付与時の動作が変わる可能性
- `visit_count` が正しく計算されない可能性

**対策:**
1. 既存のトリガー関数の定義を確認
2. 新しいロジックとの差分を確認
3. 必要に応じてロールバック手順を準備

### リスク3: 大量データのUPDATE処理

**発生条件:** `stamp_history` のレコード数が多い場合（数万件以上）

**影響:**
- UPDATE処理に時間がかかる
- 処理中にタイムアウトする可能性

**対策:**
1. 事前にレコード数を確認
2. 大量の場合は、バッチ処理に分割することを検討

---

## ロールバック手順

万が一、問題が発生した場合のロールバック手順:

### 手順1: `visit_count` カラムの削除

```sql
-- profiles テーブルから visit_count を削除
ALTER TABLE profiles DROP COLUMN IF EXISTS visit_count;
```

### 手順2: `stamp_history.amount` カラムの削除

```sql
-- stamp_history テーブルから amount を削除
ALTER TABLE stamp_history DROP COLUMN IF EXISTS amount;
```

### 手順3: トリガー関数の復元

**⚠️ 重要:** 既存のトリガー関数の定義をバックアップしておく必要があります。

```sql
-- 既存のトリガー関数をバックアップ（実行前に必ず取得）
-- 以下のクエリで既存定義を取得してテキストファイルに保存
SELECT pg_get_functiondef(oid)
FROM pg_proc
WHERE proname = 'update_profile_stamp_count';
```

ロールバック時:
```sql
-- バックアップした関数定義を使って復元
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  -- （バックアップした既存の定義をここに貼り付け）
END;
$$ LANGUAGE plpgsql;
```

---

## 実行判定

### ✅ 実行してよい条件

以下の全てを満たす場合、実行可能:

1. ✅ `stamp_history` テーブルが存在する
2. ✅ `stamp_history` に必要なカラム（`user_id`, `stamp_number`, `visit_date`）が存在する
3. ✅ 既存のトリガー関数の定義をバックアップ済み
4. ✅ Supabase のバックアップが有効、または手動バックアップを取得済み

### ⚠️ 実行を延期すべき条件

以下のいずれかに該当する場合、実行を延期:

1. ❌ `stamp_history` テーブルが存在しない
2. ❌ 既存のトリガー関数の定義が不明
3. ❌ バックアップが取得できていない
4. ❌ 本番環境で、ダウンタイムを取れない時間帯

---

## 実行前の最終確認

### Step 1: 事前確認SQLを実行

```sql
-- ① stamp_history テーブルの存在確認
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name = 'stamp_history';

-- ② stamp_history のカラム確認
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'stamp_history'
ORDER BY ordinal_position;

-- ③ 既存トリガーの確認
SELECT trigger_name, event_object_table
FROM information_schema.triggers
WHERE trigger_schema = 'public'
AND event_object_table = 'stamp_history';

-- ④ 既存関数の定義をバックアップ
SELECT pg_get_functiondef(oid)
FROM pg_proc
WHERE proname = 'update_profile_stamp_count';
```

### Step 2: 結果を記録

上記SQLの実行結果を以下に記録:

```
① stamp_history テーブル: [存在する / 存在しない]

② stamp_history のカラム:
   - user_id: [存在する / 存在しない]
   - stamp_number: [存在する / 存在しない]
   - visit_date: [存在する / 存在しない]
   - amount: [存在する / 存在しない]

③ トリガー名: [                    ]

④ 既存関数の定義: [バックアップ済み / 未取得]
```

### Step 3: 実行判定

✅ 全ての確認が完了し、問題がない → **実行可能**
⚠️ いずれかの確認で問題あり → **実行延期、問題を解決後に再確認**

---

## 実行後の確認

マイグレーション実行後、以下を確認:

```sql
-- ① profiles.visit_count が追加されたか確認
SELECT column_name, data_type, column_default
FROM information_schema.columns
WHERE table_name = 'profiles' AND column_name = 'visit_count';

-- ② stamp_history.amount が追加されたか確認
SELECT column_name, data_type, column_default
FROM information_schema.columns
WHERE table_name = 'stamp_history' AND column_name = 'amount';

-- ③ 既存データの visit_count が正しく計算されたか確認
SELECT id, display_name, stamp_count, visit_count
FROM profiles
WHERE stamp_count > 0
ORDER BY stamp_count DESC
LIMIT 10;

-- ④ stamp_history の amount が 10 に設定されたか確認
SELECT user_id, visit_date, stamp_number, amount
FROM stamp_history
ORDER BY visit_date DESC
LIMIT 10;
```

**期待結果:**
- ①②: カラムが追加されていること
- ③: `stamp_count` と `visit_count` が一致すること（現在は1:1の想定）
- ④: 既存レコードの `amount` が全て 10 になっていること

---

## まとめ

### 🔍 結論

**実行前に必ず以下を確認:**

1. `stamp_history` テーブルの存在
2. 既存トリガー関数のバックアップ
3. データベースのバックアップ

これらが確認できれば、**実行可能** です。

### 📌 次のアクション

- [ ] Supabase SQL Editor で事前確認SQLを実行
- [ ] 結果を記録
- [ ] 問題なければ、008マイグレーションを実行
- [ ] 実行後の確認SQLで動作確認

---

**作成者:** Claude Code
**最終更新日:** 2026-02-16
**ステータス:** ✅ チェックリスト作成完了
